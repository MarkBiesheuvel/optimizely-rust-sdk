// External imports
use std::error::Error;

// Relative imports of sub modules
use common::setup;
mod common;

macro_rules! assert_decision {
    ($ctx: ident, $flag_key: ident, $user_id: expr, $enabled: expr, $variation_key: expr) => {{
        // Create new user context
        let user_context = $ctx.client.create_user_context($user_id);

        // Make decision for user
        let decision = user_context.decide($flag_key);

        // Assert the decision is consistent with given values
        assert_eq!(decision.enabled(), $enabled);
        assert_eq!(decision.variation_key(), $variation_key);
    }};
}

#[test]
fn qa_rollout_flag() -> Result<(), Box<dyn Error>> {
    let ctx = setup()?;
    let flag_key = "qa_rollout";

    // Test against decision generated by the Python SDK
    assert_decision!(ctx, flag_key, "user0", false, "off");
    assert_decision!(ctx, flag_key, "user1", false, "off");
    assert_decision!(ctx, flag_key, "user2", false, "off");
    assert_decision!(ctx, flag_key, "user3", true, "on");
    assert_decision!(ctx, flag_key, "user4", true, "on");
    assert_decision!(ctx, flag_key, "user5", false, "off");
    assert_decision!(ctx, flag_key, "user6", true, "on");
    assert_decision!(ctx, flag_key, "user7", true, "on");
    assert_decision!(ctx, flag_key, "user8", false, "off");
    assert_decision!(ctx, flag_key, "user9", true, "on");
    assert_decision!(ctx, flag_key, "user10", true, "on");
    assert_decision!(ctx, flag_key, "user11", true, "on");
    assert_decision!(ctx, flag_key, "user12", false, "off");
    assert_decision!(ctx, flag_key, "user13", true, "on");
    assert_decision!(ctx, flag_key, "user14", false, "off");
    assert_decision!(ctx, flag_key, "user15", true, "on");

    // Since this key is a rollout, no events should be dispatched
    assert_eq!(ctx.decisions.len(), 0);

    Ok(())
}

#[test]
fn buy_button_flag() -> Result<(), Box<dyn Error>> {
    let ctx = setup()?;
    let flag_key = "buy_button";

    // Test against decision generated by the Python SDK
    assert_decision!(ctx, flag_key, "user0", true, "primary");
    assert_decision!(ctx, flag_key, "user1", true, "danger");
    assert_decision!(ctx, flag_key, "user2", true, "primary");
    assert_decision!(ctx, flag_key, "user3", true, "primary");
    assert_decision!(ctx, flag_key, "user4", true, "danger");
    assert_decision!(ctx, flag_key, "user5", true, "success");
    assert_decision!(ctx, flag_key, "user6", true, "success");
    assert_decision!(ctx, flag_key, "user7", true, "danger");
    assert_decision!(ctx, flag_key, "user8", true, "danger");
    assert_decision!(ctx, flag_key, "user9", true, "success");
    assert_decision!(ctx, flag_key, "user10", true, "success");
    assert_decision!(ctx, flag_key, "user11", true, "danger");
    assert_decision!(ctx, flag_key, "user12", true, "danger");
    assert_decision!(ctx, flag_key, "user13", true, "danger");
    assert_decision!(ctx, flag_key, "user14", true, "success");
    assert_decision!(ctx, flag_key, "user15", true, "danger");
    assert_decision!(ctx, flag_key, "user16", true, "primary");
    assert_decision!(ctx, flag_key, "user17", true, "warning");
    assert_decision!(ctx, flag_key, "user18", true, "danger");
    assert_decision!(ctx, flag_key, "user19", true, "success");
    assert_decision!(ctx, flag_key, "user20", true, "warning");
    assert_decision!(ctx, flag_key, "user21", true, "danger");
    assert_decision!(ctx, flag_key, "user22", true, "danger");
    assert_decision!(ctx, flag_key, "user23", true, "primary");
    assert_decision!(ctx, flag_key, "user24", true, "success");
    assert_decision!(ctx, flag_key, "user25", true, "success");
    assert_decision!(ctx, flag_key, "user26", true, "primary");
    assert_decision!(ctx, flag_key, "user27", true, "warning");
    assert_decision!(ctx, flag_key, "user28", true, "primary");
    assert_decision!(ctx, flag_key, "user29", true, "danger");
    assert_decision!(ctx, flag_key, "user30", true, "success");
    assert_decision!(ctx, flag_key, "user31", true, "primary");

    // Each of those 32 users should dispatch an event
    assert_eq!(ctx.decisions.len(), 32);

    Ok(())
}

#[test]
fn invalid_flag() -> Result<(), Box<dyn Error>> {
    let ctx = setup()?;
    let flag_key = "this_flag_does_not_exist";

    // An invalid flag should always be disabled
    assert_decision!(ctx, flag_key, "user1", false, "off");
    assert_decision!(ctx, flag_key, "user2", false, "off");
    assert_decision!(ctx, flag_key, "user3", false, "off");
    assert_decision!(ctx, flag_key, "user4", false, "off");

    // Since this key does not exist, no events should be dispatched
    assert_eq!(ctx.decisions.len(), 0);

    Ok(())
}
